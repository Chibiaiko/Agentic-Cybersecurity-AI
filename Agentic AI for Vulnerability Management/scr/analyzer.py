from typing import List, Dict, Optional
from models import Vulnerability, CVSSv3Metrics, HostInfo
from miter_mapper import MitreMapper


class Analyzer:
    def __init__(self, threat_intel: Dict):
        self.threat_intel = threat_intel

        # ===== NEW: Initialize scan metadata =====
        self.scan_type: Optional[str] = None
        self.scanner_name: Optional[str] = None
        self.scan_duration: Optional[str] = None
        self.scanner_version: Optional[str] = None

    # ===== NEW: Explicit scan info setter =====
    def set_scan_info(
        self,
        scan_type: str,
        scanner_name: str,
        scan_duration: Optional[str] = None,
        scanner_version: Optional[str] = None
    ):
        """
        Set scan information that will be included in reports.
        """
        self.scan_type = scan_type
        self.scanner_name = scanner_name
        self.scan_duration = scan_duration
        self.scanner_version = scanner_version

    def deduplicate_scans(self, scans: List[Dict]) -> List[Vulnerability]:
        vuln_map = {}

        for item in scans:
            pid = item.get("plugin_id")
            if pid not in vuln_map:
                vuln = Vulnerability(
                    plugin_id=pid,
                    plugin_name=item.get("plugin_name"),
                    severity=item.get("severity"),
                    cvss_base_score=float(item.get("cvss_base_score", 0.0)),
                    description=item.get("description"),
                    solution=item.get("solution")
                )

                # ===== CVSS v3 =====
                cvss_vector = item.get("cvss_vector")
                cvss_v3_score = item.get("cvss_v3_base_score")
                if cvss_vector and cvss_v3_score is not None:
                    vuln.cvss = CVSSv3Metrics(
                        base_score=float(cvss_v3_score),
                        vector_string=cvss_vector,
                    )

                # ===== MITRE ATT&CK =====
                vuln.attack_techniques = MitreMapper.map_techniques(
                    plugin_id=pid,
                    plugin_name=item.get("plugin_name", ""),
                    description=item.get("description", ""),
                )

                vuln_map[pid] = vuln

            host_info = self._extract_host_info(item)
            if host_info:
                if not any(
                    h.ip_address == host_info.ip_address and h.port == host_info.port
                    for h in vuln_map[pid].host_details
                ):
                    vuln_map[pid].host_details.append(host_info)

            host = item.get("host")
            port = item.get("port")
            protocol = item.get("protocol")

            location_str = host
            if port and protocol:
                location_str = f"{host} ({port}/{protocol})"
            elif port:
                location_str = f"{host} ({port})"

            if location_str and location_str not in vuln_map[pid].hosts:
                vuln_map[pid].hosts.append(location_str)

        return list(vuln_map.values())

    def _extract_host_info(self, scan_item: Dict) -> Optional[HostInfo]:
        ip_address = scan_item.get("host")
        if not ip_address:
            return None

        hostname = (
            scan_item.get("hostname")
            or scan_item.get("device_name")
            or scan_item.get("host_name")
            or scan_item.get("computer_name")
        )

        private_ip = scan_item.get("private_ip")
        public_ip = scan_item.get("public_ip")

        port = scan_item.get("port")
        if isinstance(port, str):
            try:
                port = int(port)
            except ValueError:
                port = None

        return HostInfo(
            ip_address=ip_address,
            hostname=hostname,
            private_ip=private_ip,
            public_ip=public_ip,
            port=port,
            protocol=scan_item.get("protocol"),
            mac_address=scan_item.get("mac_address"),
            os_type=scan_item.get("os_type") or scan_item.get("operating_system"),
            os_version=scan_item.get("os_version"),
        )

    def prioritize_vulnerabilities(self, vulns: List[Vulnerability]) -> List[Vulnerability]:
        for v in vulns:
            score = v.cvss_base_score
            reasons = []

            ti = self.threat_intel.get(v.plugin_id)
            if ti:
                if ti.get("exploit_available"):
                    score += 2.0
                    reasons.append("Exploit Available")
                if ti.get("rce"):
                    score += 3.0
                    reasons.append("Remote Code Execution Risk")
                if ti.get("threat_actor_usage") == "High":
                    score += 2.0
                    reasons.append("Active Threat Actor Usage")

            if "SSL" in v.plugin_name or "TLS" in v.plugin_name:
                reasons.append("Potential Crypto Weakness")

            v.risk_score = min(score, 10.0)

            if score >= 9.0 or (ti and ti.get("rce")):
                v.priority = "Priority 1"
            elif score >= 7.0:
                v.priority = "Priority 2"
            else:
                v.priority = "Priority 3"

            v.risk_reason = "; ".join(reasons) if reasons else "Based on CVSS Score"

        return sorted(vulns, key=lambda x: x.risk_score, reverse=True)
