from dataclasses import dataclass, field
from typing import List, Optional, Dict

# ==================== TERMINAL COLOR SUPPORT ====================

SEVERITY_COLORS = {
    "Critical": "\033[91m",        # Red
    "High": "\033[38;5;208m",      # Orange
    "Medium": "\033[93m",          # Yellow
    "Low": "\033[32m",             # Dark Green
    "None": "\033[94m",            # Light Blue
    "Info": "\033[97m",            # White
}

RESET_COLOR = "\033[0m"

# ==================== NEW ENHANCEMENTS ====================

@dataclass(frozen=True)
class MitreAttackTechnique:
    technique_id: str
    technique_name: str
    tactic: str

    def to_dict(self) -> Dict:
        return {
            "id": self.technique_id,
            "name": self.technique_name,
            "tactic": self.tactic,
        }


@dataclass
class CVSSv3Metrics:
    base_score: float
    vector_string: str
    severity_rating: str = ""

    def __post_init__(self):
        if not self.severity_rating:
            if self.base_score >= 9.0:
                self.severity_rating = "Critical"
            elif self.base_score >= 7.0:
                self.severity_rating = "High"
            elif self.base_score >= 4.0:
                self.severity_rating = "Medium"
            elif self.base_score > 0:
                self.severity_rating = "Low"
            else:
                self.severity_rating = "None"

    # ===== NEW: COLORIZED SEVERITY =====
    def colored_severity(self) -> str:
        color = SEVERITY_COLORS.get(self.severity_rating, "")
        return f"{color}{self.severity_rating}{RESET_COLOR}"

    def to_dict(self) -> Dict:
        return {
            "base_score": self.base_score,
            "vector": self.vector_string,
            "severity_rating": self.severity_rating,
        }


# ==================== HOST INFORMATION ====================

@dataclass
class HostInfo:
    ip_address: str
    hostname: Optional[str] = None
    private_ip: Optional[str] = None
    public_ip: Optional[str] = None
    port: Optional[int] = None
    protocol: Optional[str] = None
    mac_address: Optional[str] = None
    os_type: Optional[str] = None
    os_version: Optional[str] = None

    def to_dict(self) -> Dict:
        return {
            "ip_address": self.ip_address,
            "hostname": self.hostname,
            "private_ip": self.private_ip,
            "public_ip": self.public_ip,
            "port": self.port,
            "protocol": self.protocol,
            "mac_address": self.mac_address,
            "os_type": self.os_type,
            "os_version": self.os_version,
        }

    def __str__(self) -> str:
        parts = []

        if self.hostname:
            parts.append(self.hostname)

        if self.private_ip:
            parts.append(f"({self.private_ip})")
        else:
            parts.append(f"({self.ip_address})")

        if self.public_ip:
            parts.append(f"[Public: {self.public_ip}]")

        if self.port:
            parts.append(f"{self.port}/{self.protocol or ''}".rstrip("/"))

        return " ".join(parts)


# ==================== EXTENDED VULNERABILITY ====================

@dataclass
class Vulnerability:
    plugin_id: str
    plugin_name: str
    severity: str
    cvss_base_score: float
    description: str
    solution: str
    hosts: List[str] = field(default_factory=list)
    risk_score: float = 0.0
    risk_reason: str = ""
    priority: str = "Low"
    remediation_plan: str = ""

    cvss: Optional[CVSSv3Metrics] = None
    attack_techniques: List[MitreAttackTechnique] = field(default_factory=list)
    host_details: List[HostInfo] = field(default_factory=list)

    # ===== NEW: COLORIZED SEVERITY =====
    def colored_severity(self) -> str:
        color = SEVERITY_COLORS.get(self.severity, "")
        return f"{color}{self.severity}{RESET_COLOR}"

    def to_dict(self) -> Dict:
        result = {
            "plugin_id": self.plugin_id,
            "title": self.plugin_name,
            "severity": self.severity,
            "cvss": self.cvss_base_score,
            "risk_score": self.risk_score,
            "priority": self.priority,
            "hosts_affected": len(self.hosts),
            "risk_reason": self.risk_reason,
        }

        if self.cvss:
            result["cvss_v3"] = self.cvss.to_dict()

        if self.attack_techniques:
            result["mitre_attack"] = [t.to_dict() for t in self.attack_techniques]

        if self.host_details:
            result["host_details"] = [h.to_dict() for h in self.host_details]

        return result


# ==================== SCAN SUMMARY ====================

@dataclass
class ScanSummary:
    date: str
    scans_analyzed: int
    scanned_hosts: List[str]
    raw_vulnerabilities: int
    unique_vulnerabilities: int
    severity_breakdown: dict
    top_risks: List[dict]
    priority_summary: dict
    overall_risk_posture: str
    executive_summary: str
    recommended_next_actions: str

    with_cvss: int = 0
    with_mitre_mapping: int = 0
    scan_type: str = "Unknown"
    scan_duration: str = "Unknown"
    scanner_name: str = "Unknown"
    scanner_version: Optional[str] = None
    with_host_details: int = 0

    def to_dict(self) -> Dict:
        return {
            "scans_analyzed": self.scans_analyzed,
            "scanned_hosts": self.scanned_hosts,
            "raw_vulnerabilities": self.raw_vulnerabilities,
            "unique_vulnerabilities": self.unique_vulnerabilities,
            "severity_breakdown": self.severity_breakdown,
            "top_risks": self.top_risks,
            "priority_summary": self.priority_summary,
            "overall_risk_posture": self.overall_risk_posture,
            "executive_summary": self.executive_summary,
            "recommended_next_actions": self.recommended_next_actions,
            "enrichment_metrics": {
                "with_cvss_v3": self.with_cvss,
                "with_mitre_attack": self.with_mitre_mapping,
                "with_host_details": self.with_host_details,
            },
            "scan_information": {
                "scan_type": self.scan_type,
                "scan_duration": self.scan_duration,
                "scanner_name": self.scanner_name,
                "scanner_version": self.scanner_version,
            },
        }
