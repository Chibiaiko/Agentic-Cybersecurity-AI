from dataclasses import dataclass, field
from typing import List, Optional, Dict

# ==================== NEW ENHANCEMENTS ====================

@dataclass(frozen=True)
class MitreAttackTechnique:
    """
    Represents a MITRE ATT&CK technique mapped to a vulnerability.
    
    Attributes:
        technique_id: MITRE ID (e.g., "T1047", "T1059.001")
        technique_name: Human-readable name (e.g., "Windows Management Instrumentation")
        tactic: MITRE tactic (e.g., "Execution", "Privilege Escalation")
    
    Note: frozen=True makes this hashable, allowing deduplication via sets
    """
    technique_id: str
    technique_name: str
    tactic: str
    
    def to_dict(self) -> Dict:
        return {
            "id": self.technique_id,
            "name": self.technique_name,
            "tactic": self.tactic,
        }


@dataclass
class CVSSv3Metrics:
    """
    CVSS v3 base score and metadata.
    
    Attributes:
        base_score: CVSS v3 base score (0.0-10.0)
        vector_string: CVSS v3 vector (e.g., "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H")
        severity_rating: Human-readable rating (Critical, High, Medium, Low, None)
    """
    base_score: float
    vector_string: str
    severity_rating: str = ""  # Will be auto-populated from base_score if empty
    
    def __post_init__(self):
        """Auto-populate severity_rating from base_score if not provided."""
        if not self.severity_rating:
            if self.base_score >= 9.0:
                self.severity_rating = "Critical"
            elif self.base_score >= 7.0:
                self.severity_rating = "High"
            elif self.base_score >= 4.0:
                self.severity_rating = "Medium"
            elif self.base_score > 0:
                self.severity_rating = "Low"
            else:
                self.severity_rating = "None"
    
    def to_dict(self) -> Dict:
        return {
            "base_score": self.base_score,
            "vector": self.vector_string,
            "severity_rating": self.severity_rating,
        }


# ==================== NEW: HOST INFORMATION CLASS ====================

@dataclass
class HostInfo:
    """
    Host/Device information for vulnerability findings.
    
    Attributes:
        ip_address: Primary IP address (can be private or public)
        hostname: Device/host name
        private_ip: Private IP address (e.g., 192.168.x.x, 10.x.x.x)
        public_ip: Public IP address (external IP)
        port: Port number (optional)
        protocol: Protocol (tcp, udp, etc.)
        mac_address: MAC address (optional)
        os_type: Operating system type (Windows, Linux, etc.)
        os_version: OS version (optional)
    """
    ip_address: str
    hostname: Optional[str] = None
    private_ip: Optional[str] = None
    public_ip: Optional[str] = None
    port: Optional[int] = None
    protocol: Optional[str] = None
    mac_address: Optional[str] = None
    os_type: Optional[str] = None
    os_version: Optional[str] = None
    
    def to_dict(self) -> Dict:
        return {
            "ip_address": self.ip_address,
            "hostname": self.hostname,
            "private_ip": self.private_ip,
            "public_ip": self.public_ip,
            "port": self.port,
            "protocol": self.protocol,
            "mac_address": self.mac_address,
            "os_type": self.os_type,
            "os_version": self.os_version,
        }
    
    def __str__(self) -> str:
        """Human-readable host representation."""
        parts = []
        
        if self.hostname:
            parts.append(f"{self.hostname}")
        
        if self.private_ip:
            parts.append(f"({self.private_ip})")
        elif self.ip_address:
            parts.append(f"({self.ip_address})")
        
        if self.public_ip:
            parts.append(f"[Public: {self.public_ip}]")
        
        if self.port and self.protocol:
            parts.append(f"{self.port}/{self.protocol}")
        elif self.port:
            parts.append(f":{self.port}")
        
        return " ".join(parts)


# ==================== EXTENDED VULNERABILITY CLASS ====================

@dataclass
class Vulnerability:
    plugin_id: str
    plugin_name: str
    severity: str
    cvss_base_score: float
    description: str
    solution: str
    hosts: List[str] = field(default_factory=list)
    risk_score: float = 0.0
    risk_reason: str = ""
    priority: str = "Low"  # Priority 1, 2, 3
    remediation_plan: str = ""
    
    # ===== NEW FIELDS FOR CVSS + MITRE SUPPORT =====
    cvss: Optional[CVSSv3Metrics] = None  # Optional CVSS v3 metrics
    attack_techniques: List[MitreAttackTechnique] = field(default_factory=list)  # MITRE ATT&CK techniques
    
    # ===== NEW FIELDS FOR HOST INFORMATION =====
    host_details: List[HostInfo] = field(default_factory=list)  # Detailed host information
    
    def to_dict(self):
        """Serialize to dict, including new CVSS, ATT&CK, and host info fields."""
        result = {
            "plugin_id": self.plugin_id,
            "title": self.plugin_name,
            "severity": self.severity,
            "cvss": self.cvss_base_score,
            "risk_score": self.risk_score,
            "priority": self.priority,
            "hosts_affected": len(self.hosts),
            "risk_reason": self.risk_reason
        }
        
        # Add CVSS v3 metrics if available
        if self.cvss:
            result["cvss_v3"] = self.cvss.to_dict()
        
        # Add MITRE ATT&CK techniques if available
        if self.attack_techniques:
            result["mitre_attack"] = [t.to_dict() for t in self.attack_techniques]
        
        # Add detailed host information if available
        if self.host_details:
            result["host_details"] = [h.to_dict() for h in self.host_details]
        
        return result


@dataclass
class ScanSummary:
    date: str
    scans_analyzed: int
    scanned_hosts: List[str]  # Track unique IPs scanned
    raw_vulnerabilities: int
    unique_vulnerabilities: int
    severity_breakdown: dict
    top_risks: List[dict]
    priority_summary: dict
    overall_risk_posture: str
    executive_summary: str
    recommended_next_actions: str
    
    # ===== NEW FIELDS FOR ENRICHMENT TRACKING =====
    with_cvss: int = 0  # Count of vulnerabilities with CVSS v3 data
    with_mitre_mapping: int = 0  # Count of vulnerabilities with MITRE ATT&CK mapping
    
    # ===== NEW FIELDS FOR SCAN INFORMATION =====
    scan_type: str = "Unknown"  # Type of scan (Vulnerability, Port Scan, Compliance, etc.)
    scan_duration: str = "Unknown"  # Duration of scan
    scanner_name: str = "Unknown"  # Name of scanner (Tenable, Qualys, OpenVAS, etc.)
    scanner_version: Optional[str] = None  # Version of scanner
    with_host_details: int = 0  # Count of vulnerabilities with detailed host info

    def to_dict(self):
        """Serialize to dict, including new enrichment tracking and scan info fields."""
        result = {
            "scans_analyzed": self.scans_analyzed,
            "scanned_hosts": self.scanned_hosts,
            "raw_vulnerabilities": self.raw_vulnerabilities,
            "unique_vulnerabilities": self.unique_vulnerabilities,
            "severity_breakdown": self.severity_breakdown,
            "top_risks": self.top_risks,
            "priority_summary": self.priority_summary,
            "overall_risk_posture": self.overall_risk_posture,
            "executive_summary": self.executive_summary,
            "recommended_next_actions": self.recommended_next_actions,
        }
        
        # Add enrichment metrics
        result["enrichment_metrics"] = {
            "with_cvss_v3": self.with_cvss,
            "with_mitre_attack": self.with_mitre_mapping,
            "with_host_details": self.with_host_details,
        }
        
        # Add scan information
        result["scan_information"] = {
            "scan_type": self.scan_type,
            "scan_duration": self.scan_duration,
            "scanner_name": self.scanner_name,
            "scanner_version": self.scanner_version,
        }
        
        return result
